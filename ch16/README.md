# 테스팅

## 테스팅의 필요성 

테스팅은 주로 검증을 수행하며 디버깅과는 다른 목적을 띈다. 디버깅은 단지 오류를 수정하는 활동에 지나지 않지만, 테스팅은 오류가 없는 코드라도 실제 오류가 없는 코드인지 객관적으로 검증함으로써 코드의 품질을 높이는 활동이다. 테스킹은 수행 방식에 따라 다음과 같이 나뉜다.

* 단위 테스팅(unit testing): 코드 수준에서 각 모듈에 대한 테스팅
* 통합 테스팅(integration testing): 외부 모듈을 기존 모듈과 통합해 진행하는 테스팅
* 시스템 테스팅(system testing): 시장 출시 전 완성된 제품을 대상으로 진행하는 테스팅
* 인수 테스팅(acceptance testing): 제품의 사용자들을 대상으로 진행하는 테스팅

테스팅을 하면 다음과 같은 효과가 있다.

* 테스팅은 코드의 결함을 조기에 발견할 수 있다.
* 테스팅은 프로젝트 규모가 커질수록 디버깅 시간을 감소시킨다.
* 테스팅은 코드의 품질과 요구사항 준수 여부를 객관적으로 확인할 수 있게 한다.
  
모든 종류의 테스팅을 수행하기는 어렵지만, 단위 테스팅만큼은 프로젝트 규모가 커질수록 개발 속도를 높이고 에러를 줄이는 면에서 필수이다. 단위 테스팅은 소프트웨어 개발의 생명주기에서 구현 단계부터 진행된다. 소프트웨어 개발의 생명 주기는 다음과 같다.   
요구사항 정의 -> 요구사항 분석 -> 설계 -> 구현 -> 테스트 -> 운영 및 유지 보수   

코드의 규모가 커지고 코드 변경이 잦아지면 문제를 발견하고 고치는 시간이 늘어난다. 개발 단계뿐 아니라 유지보수 시에도 문제를 발견하고 고치는 활동이 계속돼 비용이 늘어난다. 이러한 점에서 단위 테스팅은 문제를 조기에 발견하고 견고한 시스템을 만들기 위한 필수 활동이다. 단위 테스팅은 바라보는 관점에 따라 TDD 방식과 BDD 방식으로 나뉜다.

## TDD와 단위 테스팅

<b> TDD(Test Driven Development, 테스트 주도 개발)</b>은 견고한 코드를 만들기 위해 테스트에 기반을 둔 개발 방식이다.   
TDD는 오류를 없애는 활동이 아닌 요구사항에 명시된 기능을 제대로 구현했는지 검증해 코드의 품질을 점진적으로 개선하는 활동이다.   
TDD는 요구사항에 따라 테스트 코드를 작성한다. 그 후 코드를 통과 테스트와 실패 테스트에 테스트해본다. 통과 테스트는 각 테스트 케이스가 의도대로 동작하는지를 확인한다. 실패 테스트는 고의로 코드가 실패하도록 테스트 케이스를 추가한다. 코드가 의도대로 동작하지 않으면 코드를 수정해 다시 테스트를 진해안다. 테스트가 성공했어도 더 완성도 있는 코드를 위해 지속적은 리팩터링이 필요하다. 여기서 리팩터링은 동작의 변화 없이 코드를 개선해 코드의 가독성과 성능 등을 높이는 작업다. 리팩터링을 수행할 때 다음과 같은 점을 고려해 진행한다.

1. 중복 코드는 함수로 분리한다.
2. 사용되지 않는 코드(죽은 코드)는 제거한다
3. 함수명이나 변수명이 코딩 컨벤션(coding conventions)에 적합한지 확인한다.
4. 함수에서 매개변수를 많이 사용한다면 적절히 개수를 조정한다.
5. 비슷한 유형의 변수가 많으면 클래스 등의 단위로 분리해 정의한다.
6. 클래스나 함수를 적정 크기로 유지하고 커지면 클래스나 함수로 분리한다.

리팩터링은 테스트 코드의 가독성과 재사용성을 높이고 테스트 코드의 구조를 간결하게 바꾸는 데 도움이 된다.

# BDD와 BDD 테스팅
TDD는 요구사항 명세를 고려해 테스트 계획을 수립하는데 비즈니스 관점과 사용자의 관점을 반영해 테스트할 수 없다는 단점이 있다.   

<b>BDD(Behavior Driven Development, 행위 주도 개발)</b>는 비즈니스 목표를 달성하기 위해 사용자와의 의사소통을 바탕으로 사용자 관점에 초점을 맞춰 제품을 개발하려는 목표가 있다. 따라서 BDD는 사용자 스토리(사용자 관점)를 고려해 내부 기능이 제대로 동작하는지를 테스트한다.  
사용자 스토리는 비즈니스 목표 달성과 관련해 사용자의 역할을 정의하고, 원하는 기능, 얻을 수 있는 가치에 대해 서술한다. 사용자 스토리에 대한 수집을 마치면 스토리로부터 여러 시나리오를 추출할 수 있다.   
작성한 시나리오는 BDD의 사양서(specification)에 따라 시나리오의 상황이 어떤지, 사건은 언제 발생하는지, 사건에 따라 어떤 결과가 생기는지를 'Given(상황)-When(시간)-Then(결과)'의 순서로 정리 작성한다.
시나리오에서 상황-사건-결과의 각 단계에 대해서는 부가 작업을 추가(Add)할 수 있다.

><b>[시나리오 출금하기]</b>   
1) 유효한 카드 번호를 ATM 기기에 넣었다(Given)   
    : 카드를 넣고 카드 번호가 유효한지 확인한다(Add)
2) 100만 원을 출금 신청했다(When)   
    : 계좌에 잔액을 확인한다(Add)
3) 예금 잔액이 100만 원으로 줄었다(Then)   
    : 카드가 반환된다(Add)

 시나리오가 작성됐다면 BDD의 시나리오 중심으로 테스트를 진행할 수 있다. 하나의 시나리오는 하나의 테스트 케이스에 해당한다. 시나리오를 테스트에 적용하는 과정은 다음과 같다.

* 시나리오 테스트를 위한 시나리오를 작성한다.
* 시나리오에서 테스트 가능한 테스트 케이스(실패, 통과 테스트 포함)를 선택해 구현한다.
* 시나리오 테스트에 실패했다면 리팩터링을 진행한다.
* 시나리오 테스트에 성공했다면 다음 시나리오 테스트를 수행한다.

테스트 프레임워크는 모카(mocha), 재스민(jasmine), Qunit 등이 있다.     
gulp는 태스크 러너로서 테스트에 필요한 작업들을 수행한다. 예를 들어 테스트 전에 타입스크립트를 컴파일하고 컴파일 결과를 모카로 전달하는 방식으로 단위 작업들을 차례로 실행한다.   

## DOM 테스트
<b>DOM(Document Object Model)</b>은 HTML 페이지의 구조나 HTML 문서를 표시하고 다루는 데 필요한 정보를 담고 있다.   
DOM의 내용 중 DOM 트리는 HTML 콘텐츠 자체에 대한 엘리먼트들을 포함한다. 예를 들어 div, p, table 등과 같은 엘리먼트가 DOM 트리를 구성한다.   
DOM 테스트는 기능 엘리먼트와 디장인 엘리먼트를 구분한다. 기능 엘리먼트는 그 자체로 기능을 담당하므로 결함이 존재하거나 삭제되면 시스템 공작에 영향을 미칠 수 있다. 따라서 기능 엘리먼트가 제대로 동작하는지 검증이 필요하다. 반면 디자인 엘리먼트는 삭제되더라도 디자인에 영향을 미칠 수는 있지만, 시스템 기능을 동작하지 못하게 하는 오류를 발생시키지는 않는다.